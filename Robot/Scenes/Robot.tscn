[gd_scene load_steps=15 format=2]

[ext_resource path="res://Resources/Roboter/RBGODO.glb" type="PackedScene" id=1]

[sub_resource type="GDScript" id=2]
script/source = "extends KinematicBody

# positive y-speed when jumping (pixels per second)
const JUMP_FORCE = 8     
# negative y-acceleration to display gravity
const GRAVITY = 16 
# maximum y-speed the player can have downwards
const MAX_FALL_SPEED = 20       
# maximum y-speed the player can have without using any abilities
# when using an ability, player can wlek twice as fast (15)
const MAX_MOVE_SPEED = 5.5 

# holds the information of the current velocioty of the player
var velocity = Vector3.ZERO

# determines the direction the player is looking
var facing_right = true


# id true while the player is in the air
var jumping = false
# is true when the player is able two make his first jump
var able = true

# is true when the level allows to jump mid air once
var doublejump = false # true

# is true when the player is able to make the second jump
var able2 = false
# is true when the second jump was used
var jumping2 = false


# is true when the level allows to activate the ability speedboost
var speedboost = false # true  

# the ability will move the player double the speed for 5 seconds
const ABILITY_DURATION = 5  
# to measure when the ability runs out
var duration = ABILITY_DURATION
# cooldown time until the player can activate the ability again
const ABILITY_COOLDOWN = 10
# to measure time of cooldown
var cooldown = ABILITY_COOLDOWN

# variables to determine which animition to play when starting or stopping to walk
# e.g. while accerating the player leans forward
var lean = 0
var leanchange = 0.2

# variables to determine which respawnpoint is currently active and where it is
var respawn_point = Vector3(0,0.99,0)
var current_checkpoint = null

# variable for tries needed and the time played
var tries = 0
# 
var game_timer = 0

#caches path for creating instance of Bullet.tscn
const bulletpath = preload(\"res://Scenes/Bullet.tscn\")
var allowShoot = true
var stimer = null
var bulletdelay = 1

# instance to play eanimations
onready var anim_player = $Graphics/RBGODO/AnimationPlayer


# when starting the scene, this will set conditions
func _ready():
	# target fps, should be so the wheel does not appear to spin in the wrong direction when moving
	Engine.target_fps = 400
	
	$Graphics/RBGODO/AnimationTree.active = true
	$Graphics/RBGODO/AnimationTree.set(\"parameters/Blend_Idle_Drive/blend_amount\",0)
	
	#timer for shoot delay
	stimer = Timer.new()
	stimer.set_one_shot(true)
	stimer.set_wait_time(bulletdelay)
	stimer.connect(\"timeout\", self, \"on_stime_complete\")
	add_child(stimer)

# Hauptfunktion der Physikalischen Prozesse
func _physics_process(delta): 
	# will get the direction of movement in a vector (x and y can be 1 or -1)
	var input = get_input(delta)
	
	
	#all animations are beeing handled here
	if !IsMovingRounded():
		if lean > 0:
			lean = lean - leanchange
		$Graphics/RBGODO/AnimationTree.set(\"parameters/Blend_Idle_Drive/blend_amount\",lean)
	
	if input.x == 1 or input.x == -1:
		if lean < 1:
			lean = lean + leanchange
		$Graphics/RBGODO/AnimationTree.set(\"parameters/Blend_Idle_Drive/blend_amount\",lean)
	
	if Input.is_action_pressed(\"jump\") && able:
		$Graphics/RBGODO/AnimationTree.set(\"parameters/Blend_jump/active\",true)
		
	elif Input.is_action_pressed(\"jump\") && able2 && doublejump:
		$Graphics/RBGODO/AnimationTree.set(\"parameters/Blend_doublejump/active\",true)
		
	if Input.is_action_pressed(\"shoot\"):
		$Graphics/RBGODO/AnimationTree.set(\"parameters/Blend_Shoot_Ani/active\",true)
#		if allowShoot:
#			shoot()
	
	# determines x velovity
	get_v_x(delta, input.x)
	# determines y velovity
	get_v_y(delta, input.y)
	
	# will flip the facing of the player, when moving opposite direction
	if input.x < 0 and facing_right:
		flip()
	if input.x > 0 and !facing_right:
		flip()
		
	# if on floor the variables concerning the jumps have to be reset
	
	#if !is_on_floor():
		# this is so the second jump can be made if driving of a ledge instead of jumping the first time
		#jumping = true
	
	
	var snap = Vector3.ZERO #Vector3.DOWN if not jumping else Vector3.ZERO
	move_and_slide_with_snap(velocity, snap, Vector3.UP, true, 4, deg2rad(60))
	
	#move_and_slide(velocity, Vector3.UP, true, 4, deg2rad(60))
	
	if is_on_floor():
		able = true
		able2 = false
		jumping = false
		jumping2 = false
	else:
		# this is so the second jump can be made if driving of a ledge instead of jumping the first time
		jumping = true
	
	game_timer += delta
	
	var cur_pos = Vector3.ZERO
	cur_pos = transform.origin
	if cur_pos.y < -10:
		die()
	






func IsMovingRounded():
		return (abs(velocity.length()) > 1)

# get_input returns a vector with x and y directions in form of signs (x and y can be 1 or -1)
func get_input(delta):
	var input = Vector3.ZERO
	
	if Input.is_action_pressed(\"move_right\"):
		input.x += 1
	if Input.is_action_pressed(\"move_left\"):
		input.x -= 1
	if Input.is_action_pressed(\"jump\"):
		input.y += 1
	# only when the jump buitton is released after the first jump, the player can make the second jump
	if Input.is_action_just_released(\"jump\") && jumping && !jumping2:
		able2 = true
	if Input.is_action_pressed(\"crouch\"):
		input.y -= 1
		
	
	if Input.is_action_pressed(\"ability\") && speedboost && cooldown == ABILITY_COOLDOWN:
		duration -= delta
	input = do_ability(delta, input)
	
	return input




# when the ability speed boost is activated, the x values in the input vector are set to the 
# absolute value of 2 so the speed is multiplied with 2
# also measures whether the ability is still on cooldown
func do_ability(delta, input):
	
	if duration == ABILITY_DURATION && cooldown == ABILITY_COOLDOWN:
		return input
		
	elif cooldown != ABILITY_COOLDOWN:
		cooldown -= delta
		if cooldown < delta:
			cooldown = ABILITY_COOLDOWN
		return input
		
	elif duration != ABILITY_DURATION:
		duration -= delta
		if duration < delta:
			duration = ABILITY_DURATION
			cooldown -= delta
		input.x *= 2
		return input
		
	else:
		return input
	 




# get_v_x sets the new velocity on the x-axis inside the global variable velocity (type: Vector3D)
func get_v_x(delta, dir):
	# delta is a set value of frames per second so when calculating velocity, it will be independent
	# of fps but will give the same position, as now speeds can be calculated in pixels/second instead
	
	var temp_dir = dir
	
	# when moving and the keys are no longer held down, this will provide a smooth force in opposite
	# directrion of the current velocity, so it seems as the player is breaking
	if dir == 0:
		# when no keys (a or d) held input.x == 0 so opposite direction is applied
		if velocity.x < -0.5:
			dir += 1
		elif velocity.x > 0.5:
			dir -= 1
		# if the value is below .5 in each direction the player will stand still or he will slide 
		# unintendedly over the ground
		else:
			velocity.x = 0
	
	# this formula will give accelerated movement
	velocity.x += dir + 0.25 * dir * MAX_MOVE_SPEED * delta
	
	# this will give temp_dir the direction of the motion in 1 or -1
	if velocity.x != 0:
		temp_dir = velocity.x / abs(velocity.x)
	
	# max Speed will be determined so dependent of the ability speedboost
	var maxS = MAX_MOVE_SPEED
	if duration < ABILITY_DURATION:
		maxS *= 2
	
	# if the velocity is bigger then the max, it wil be cut down to max Velocity	
	if velocity.x > maxS || velocity.x < -maxS:
		velocity.x = temp_dir * maxS
	



# this function will determine the speed in y-direction
func get_v_y(delta, dir):
	
	# when mid-air and the player hits the ceiling, he should not stick at it because of momentum
	# for that to happen it is cut down to a specific value, that makes it feel more natural
	if is_on_ceiling():
		velocity.y = 0
		
		
	# this bit will calculate the new y velocity as a result of gravity
	velocity.y -= GRAVITY * delta
	if velocity.y < -MAX_FALL_SPEED:
		velocity.y = -MAX_FALL_SPEED
	
	# so the player constantly is pushed into the ground and will not float on the ground
	if !jumping:
		velocity.y = -0.1
	
	# this part will disable the player to jump for the first time when falling of a ledge
	# and enabling the player to take the second jump instead
	if able && jumping:
		able = false
		able2 = true
		
	# if space is pressed the player will jump if able to
	if dir == 1:
		# if not already jumping and able to jump
		if !jumping && able:
			jump(dir)
		
		# if not haveing used the second jump, if able to jump twice and the feature
		# doubljump is active
		elif !jumping2 && able2 && doublejump:
			jump2(dir)
	
	# if s is pressed player will quickly drop downm to the floor
	elif dir == -1:
		crouch(dir)
	
	
# this will apply the jump force to the y-velocity of the player
func jump(dir):
	velocity.y = JUMP_FORCE
	# upon called player is now jumping
	jumping = true
	# player is not anymore able to use first jump
	able = false

# this will apply a part of jump force to the y-velocity of the player as second jump
func jump2(dir):
	velocity.y = JUMP_FORCE * 3/4
	# player has used second jump
	jumping2 = true
	# player is not anymore able to use second jump
	able2 = false
	

# this will apply high negative y-velocity so the player is down to the ground very quickly
func crouch(dir):
	velocity.y = -(MAX_FALL_SPEED / 2)

# if facing the wrong way, this method will flip the direction the player is looking to
func flip():
	facing_right = !facing_right
	for x in range(15):
		$Graphics.rotation_degrees.y += 12
		yield(get_tree().create_timer(0.001), \"timeout\")



# if called, the player will die, respawn and the try-counter goes up by 1
func die():
	
	transform.origin = respawn_point
	
	tries += 1
	
	print()
	print(\"You died!\")
	print(\"Attempts: \" + String(tries))
	print(\"Time:     \" + String(game_timer))
	print()

func set_checkpoint(area):
	
	
	var checkpoint = area.get_parent()
	
	var pos
	
	if !checkpoint.is_active():
		if checkpoint.has_method(\"activate_checkpoint\"):
			
			if current_checkpoint == null:
				pass
			elif current_checkpoint != checkpoint:
				var last_checkpoint = current_checkpoint
				last_checkpoint.deactivate_checkpoint()
			
			respawn_point = checkpoint.activate_checkpoint()
			current_checkpoint = checkpoint
		else:
			print(\"Method activate_checkpoint not found\")
	else:
		print(current_checkpoint.name + \" already active\")




func _on_RestartButton_pressed():
	die()


func _on_CollisionArea_area_entered(area):
	print(\"Robot collided with area \"+ area.get_parent().name + \": \")
	print(area.get_groups())
	if area.is_in_group(\"killing\"):
		die()
	if area.is_in_group(\"spawnpoint\"):
		set_checkpoint(area)
	if area.is_in_group(\"detectionZone\"):
		area.get_parent().do_animation()
	pass # Replace with function body.

#func _on_CollisionArea_area_shape_entered(area_rid, area, area_shape_index, local_shape_index):
	#print(\"Test collision area_shape\")
	#print(area.name)
	#pass # Replace with function body.
	
func _on_CollisionArea_body_entered(body):
	#print(\"Robot collided with body \" + body.name)
	pass # Replace with function body.

#func _on_CollisionArea_body_shape_entered(body_rid, body, body_shape_index, local_shape_index):
	#print(\"Test collision body_shape\")
	#print(body.name)
	#pass # Replace with function body.

#func shootBulletInstances():
	#var bullet = bulletpath.instance()
	
	#get_parent().add_child(bullet)
	#bullet.translation = $BulletOrigin.global_transform.origin

#unc shoot():
	#shootBulletInstances()
	##yield(get_tree().create_timer(0.5), \"timeout\")
	#shootBulletInstances()
	#allowShoot = false
	#stimer.start()

#func on_stime_complete():
	#allowShoot = true
"

[sub_resource type="CylinderShape" id=3]
radius = 0.781103

[sub_resource type="AnimationNodeBlend2" id=11]
filters = [ "Armature/Skeleton:Heightcontroll", "Armature/Skeleton:LowArm_L", "Armature/Skeleton:LowArm_R", "Armature/Skeleton:Main", "Armature/Skeleton:R_Fix", "Armature/Skeleton:R_Fix.001", "Armature/Skeleton:R_SpringBack", "Armature/Skeleton:R_SpringBack.001", "Armature/Skeleton:R_SpringFront", "Armature/Skeleton:R_SpringFront.001", "Armature/Skeleton:R_legUP", "Armature/Skeleton:R_legUP.001", "Armature/Skeleton:R_legUP.002", "Armature/Skeleton:R_legUP.003", "Armature/Skeleton:R_legUPSta", "Armature/Skeleton:R_legUPSta.001", "Armature/Skeleton:UpArm_L", "Armature/Skeleton:UpArm_R" ]

[sub_resource type="AnimationNodeOneShot" id=7]
filter_enabled = true
filters = [ "Armature/Skeleton:LowArm_L", "Armature/Skeleton:LowArm_R", "Armature/Skeleton:Target", "Armature/Skeleton:UpArm_L", "Armature/Skeleton:UpArm_R" ]

[sub_resource type="AnimationNodeOneShot" id=6]

[sub_resource type="AnimationNodeOneShot" id=5]
filters = [ "Armature/Skeleton:Heightcontroll", "Armature/Skeleton:R_Fix", "Armature/Skeleton:R_Fix.001", "Armature/Skeleton:R_SpringBack", "Armature/Skeleton:R_SpringBack.001", "Armature/Skeleton:R_SpringFront", "Armature/Skeleton:R_SpringFront.001", "Armature/Skeleton:R_legUP", "Armature/Skeleton:R_legUP.001", "Armature/Skeleton:R_legUP.002", "Armature/Skeleton:R_legUP.003", "Armature/Skeleton:R_legUPSta", "Armature/Skeleton:R_legUPSta.001" ]

[sub_resource type="AnimationNodeAnimation" id=1]
animation = "DoppelSprung"

[sub_resource type="AnimationNodeAnimation" id=4]
animation = "Drive-loop"

[sub_resource type="AnimationNodeAnimation" id=9]
animation = "Idle-loop"

[sub_resource type="AnimationNodeAnimation" id=10]
animation = "Jump"

[sub_resource type="AnimationNodeAnimation" id=8]
animation = "Shoot"

[sub_resource type="AnimationNodeTimeScale" id=13]

[sub_resource type="AnimationNodeBlendTree" id=12]
graph_offset = Vector2( -175.913, -142.366 )
nodes/Blend_Idle_Drive/node = SubResource( 11 )
nodes/Blend_Idle_Drive/position = Vector2( 160, -160 )
nodes/Blend_Shoot_Ani/node = SubResource( 7 )
nodes/Blend_Shoot_Ani/position = Vector2( 380, -120 )
nodes/Blend_doublejump/node = SubResource( 6 )
nodes/Blend_doublejump/position = Vector2( 800, 40 )
nodes/Blend_jump/node = SubResource( 5 )
nodes/Blend_jump/position = Vector2( 600, -60 )
nodes/Doppelsprung/node = SubResource( 1 )
nodes/Doppelsprung/position = Vector2( -60, 340 )
nodes/Drive/node = SubResource( 4 )
nodes/Drive/position = Vector2( -40, -40 )
nodes/Idle-loop/node = SubResource( 9 )
nodes/Idle-loop/position = Vector2( -40, -160 )
nodes/Jump/node = SubResource( 10 )
nodes/Jump/position = Vector2( -20, 220 )
nodes/ShootAni/node = SubResource( 8 )
nodes/ShootAni/position = Vector2( -20, 100 )
nodes/TimeScale/node = SubResource( 13 )
nodes/TimeScale/position = Vector2( 460, 180 )
nodes/output/position = Vector2( 1040, 40 )
node_connections = [ "Blend_Idle_Drive", 0, "Idle-loop", "Blend_Idle_Drive", 1, "Drive", "Blend_doublejump", 0, "Blend_jump", "Blend_doublejump", 1, "TimeScale", "Blend_Shoot_Ani", 0, "Blend_Idle_Drive", "Blend_Shoot_Ani", 1, "ShootAni", "Blend_jump", 0, "Blend_Shoot_Ani", "Blend_jump", 1, "Jump", "TimeScale", 0, "Doppelsprung", "output", 0, "Blend_doublejump" ]

[node name="Robot" type="KinematicBody"]
transform = Transform( 0.5, 0, 0, 0, 0.5, 0, 0, 0, 0.5, 0, 0, 0 )
axis_lock_motion_z = true
move_lock_z = true
script = SubResource( 2 )

[node name="CollisionArea" type="Area" parent="."]
transform = Transform( 1, 0, 0, 0, -1, -8.74228e-08, 0, 8.74228e-08, -1, 0, 1.0211, 0 )

[node name="CollisionShape" type="CollisionShape" parent="CollisionArea"]
transform = Transform( 1.016, 0, 0, 0, -1.015, -1.52959e-07, 0, 1.53261e-07, -1.013, 0, -3.99351e-05, -8.92709e-08 )
shape = SubResource( 3 )

[node name="CollisionShape" type="CollisionShape" parent="."]
transform = Transform( 1, 0, 0, 0, -1, -8.74228e-08, 0, 8.74228e-08, -1, 0, 1.0211, 0 )
shape = SubResource( 3 )

[node name="Camera" type="Camera" parent="."]
transform = Transform( 2, 0, 0, 0, 2, 0, 0, 0, 2, -0.0625904, 2.02273, 18.8776 )
visible = false

[node name="Graphics" type="Spatial" parent="."]
transform = Transform( 0.8, 0, 0, 0, 0.8, 0, 0, 0, 0.8, 0, 0, 0 )

[node name="RBGODO" parent="Graphics" instance=ExtResource( 1 )]

[node name="AnimationTree" type="AnimationTree" parent="Graphics/RBGODO"]
tree_root = SubResource( 12 )
anim_player = NodePath("../AnimationPlayer")
active = true
parameters/Blend_Idle_Drive/blend_amount = 0.0
parameters/Blend_Shoot_Ani/active = false
parameters/Blend_doublejump/active = false
parameters/Blend_jump/active = false
parameters/TimeScale/scale = 1.0

[node name="BulletOrigin" type="Position3D" parent="Graphics/RBGODO"]
transform = Transform( 1.25, 0, 0, 0, 1.25, 0, 0, 0, 1.25, 2.4344, 1.2306, 0 )

[node name="CurrentLocation" type="Position3D" parent="."]

[connection signal="area_entered" from="CollisionArea" to="." method="_on_CollisionArea_area_entered"]
[connection signal="body_entered" from="CollisionArea" to="." method="_on_CollisionArea_body_entered"]

[editable path="Graphics/RBGODO"]
